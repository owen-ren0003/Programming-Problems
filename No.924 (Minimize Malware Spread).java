class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Set<Integer> nodes = new HashSet<>();
        
        //uniquely (so no repeats) stores the initially infected nodes and assign all of them value 0.
        for (int i=0; i<initial.length; i++){
            nodes.add(initial[i]+1);
        }
        
        int n = graph.length;
        int[] vsd = new int[n];
        
        //iterates over the sorted keySet();
        Map<Integer,Integer> clond = new HashMap<>();
        List<Integer> order= new ArrayList<>(nodes);
        Collections.sort(order);
        for (int node: order) {
            if (vsd[node-1]!=0) clond.remove(node);
            else {
                clond.put(node,dfs(graph, node-1, vsd, node));
            }
        }
        
        int ret = -1;
        int max = -1;
        for (int i: clond.keySet()){
            if (clond.get(i)>max) {
                ret = i-1;
                max = clond.get(i);
            }   
        }
        return ret;
    }
    
    //determines the size of the connected component given an infected node. labels all points in this connected component as mark in the array vsd.
    private int dfs(int[][] graph, int node, int[] vsd, int mark){
        int n = graph.length;
        int c=1;
        vsd[node] = mark;
        for (int j=0; j<n; j++){
            if (graph[node][j] == 1 && vsd[j]!=mark){
                c+=dfs(graph, j, vsd, mark);
            }
        }
        return c;
    }
}
